//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.17929
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;
using ws.winx.platform;
using System.ComponentModel;
using ws.winx.devices;
using System.Threading;
using System.Runtime.InteropServices;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;



namespace ws.winx.input
{

    public static class InputManager
    {



        private static InputCombination[] __inputCombinations;
        private static InputSettings __settings;//=new InputSettings();
        private static IHIDInterface __hidInterface;//=new ws.winx.platform.windows.WinHIDInterface();


        private static readonly object syncRoot = new object();


        /// <summary>
        /// Edit Mode = true stops all keys quering and checks of gameplay. Useful when use open UI to map keys to states
        /// 
        /// </summary>
        public static bool EditMode = false;


        public enum Error : ushort
        {

            NoError = 0x0,
            SettingNotLoaded = 0x1,
            //Disposing= 0x4



        }

        public static bool isReady()
        {

            //settings should be loaded
            if (InputManager.__settings == null)
            {
                Debug.LogError("InputSetting not loaded");
                return false;
            }



            return !EditMode;
        }


     








        public static IHIDInterface hidInterface
        {
            get
            {

                if (__hidInterface == null)
                {
                    //if((Application.platform & (RuntimePlatform.WindowsPlayer | RuntimePlatform.WindowsEditor))!=0){

#if UNITY_STANDALONE_WIN || UNITY_EDITOR_WIN
                    __hidInterface = new ws.winx.platform.windows.WinHIDInterface();
#endif


#if UNITY_STANDALONE_OSX || UNITY_EDITOR_OSX
						__hidInterface=new ws.winx.platform.osx.OSXHIDInterface();
#endif


#if UNITY_WEBPLAYER && !UNITY_EDITOR
						__hidInterface=new ws.winx.platform.web.WebHIDInterface();
#endif

#if UNITY_ANDROID && !UNITY_EDITOR
                          __hidInterface=new ws.winx.platform.android.AndroidHIDInterface();
#endif

                    //register events
                    __hidInterface.DeviceDisconnectEvent += new EventHandler<DeviceEventArgs<string>>(onRemoveDevice);
                    __hidInterface.DeviceConnectEvent += new EventHandler<DeviceEventArgs<IDevice>>(onAddDevice);



                    Debug.Log(__hidInterface.GetType() + " is Initialized");
                }


                //	if(_joysticks==null) _joysticks = new JoystickDevicesCollection(); 



                return __hidInterface;
            }
        }


        internal static void onRemoveDevice(object sender, DeviceEventArgs<string> args)
        {

            lock (syncRoot)
            {
                if (InputEx.Devices.ContainsID(args.data))
                {

                    //remove asigned device from InputPlayer
                    if (__settings != null && __settings.Players!=null && __settings.Players.Length > 0)
                    {

                        IDevice device = InputEx.Devices[args.data];

                        //indexOf maybe
                        for (int i = 0; i < __settings.Players.Length; i++)
                        {
                            if (device.Equals(__settings.Players[i].Device))
                            {
                                __settings.Players[i].Device = null;
                                Debug.Log("Device " + args.data + " dettached from Player" + i);
                            }
                        }
                    }

                    InputEx.Devices.Remove(args.data);
                }

            }
        }

        internal static void onAddDevice(object sender, DeviceEventArgs<IDevice> args)
        {

            lock (syncRoot)
            {
                //do not allow duplicates
                if (InputEx.Devices.ContainsID(args.data.ID))
                    return;

                InputEx.Devices[args.data.ID] = args.data;
            }

        }

        public static InputSettings Settings
        {
            get { if (__settings == null) __settings = new InputSettings(); return __settings; }
        }


        /// <summary>
        /// Returns joystick list of Type T (Idea is to get Joystick and set/use some special ablitiy like SetMotor)
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<T> GetDevices<T>()
        {

            lock (syncRoot)
            {
                IDeviceCollection devices = InputEx.Devices;

                List<T> Result = new List<T>();

                foreach (IDevice device in devices)
                {
                    if (device.GetType() == typeof(T) || device is T)
                    {
                        Result.Add((T)device);

                    }

                }



                return Result;
            }
        }

        /// <summary>
        /// Add driver that would support custom device (see WinMMDriver,OSXDriver...for HOW TO)
        /// </summary>
        /// <param name="driver"></param>
        public static void AddDriver(IDriver driver)
        {
            hidInterface.AddDriver(driver);

        }



        /// <summary>
        /// Map state to input on player with index and profile
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="player"></param>
        /// <param name="at"></param>
        /// <param name="combos"></param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params KeyCode[] combos)
        {

            MapStateToInput(stateName, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params KeyCode[] combos)
        {

            MapStateToInput(stateNameHash, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params int[] combos)
        {

            MapStateToInput(stateName, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name Hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Combos.</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params int[] combos)
        {

            MapStateToInput(stateNameHash, new InputCombination(combos), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name Hash.</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Actions. KeyExtension.Backspace.DOUBLE,...</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params InputAction[] actions)
        {

            MapStateToInput(stateNameHash, new InputCombination(actions), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name .</param>
        /// <param name="player"></param>
        /// <param name="at">At.</param>
        /// <param name="combos">Actions. ex KeyExtension.Backspace.DOUBLE,...</param>
        public static void MapStateToInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1, params InputAction[] actions)
        {

            MapStateToInput(stateName, new InputCombination(actions), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name </param>
        /// 
        /// <param name="codeCombination">Code combination.
        /// just "I" for KeyCode.I
        /// or "I"+InputAction.DOUBLE_DESIGNATOR 
        ///	 or "I"+InputAction.DOUBLE_DESIGNATOR+InputAction.SPACE_DESIGNATOR+(other code);
        ///   or just "I(x2)" depending of InputAction.DOUBLE_DESIGNATOR value
        /// </param>
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(String stateName,string codeCombination, InputPlayer.Player player = InputPlayer.Player.Player0,int at = -1)
        {

            MapStateToInput(stateName, new InputCombination(codeCombination), player, at);

        }

        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateNameHash">State name hash(int) </param>
        /// <param name="player"></param>
        /// <param name="codeCombination">Code combination.
        /// just "I" for KeyCode.I
        /// or "I"+InputAction.DOUBLE_DESIGNATOR 
        ///	 or "I"+InputAction.DOUBLE_DESIGNATOR+InputAction.SPACE_DESIGNATOR+(other code);
        ///   or just "I(x2)" depending of InputAction.DOUBLE_DESIGNATOR value
        /// </param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(int stateNameHash, String codeCombination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            MapStateToInput(stateNameHash, new InputCombination(codeCombination), player, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. (int)KeyCode.P,(int)KeyCode.Joystick2Button12,JoystickDevice.toCode(...))</param>
        public static void MapStateToInput(String stateName, InputPlayer.Player player = InputPlayer.Player.Player0, params int[] combos)
        {
            MapStateToInput(stateName, new InputCombination(combos),player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. (int)KeyCode.P,(int)KeyCode.Joystick2Button12,JoystickDevice.toCode(...))</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, params int[] combos)
        {
            MapStateToInput(stateNameHash, new InputCombination(combos),player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. KeyCodeExtension.Backspace.DOUBLE,KeyCodeExtesnion.Joystick1AxisYPositive.SINGLE)</param>
        public static void MapStateToInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, params InputAction[] actions)
        {
            MapStateToInput(stateNameHash, new InputCombination(actions),player);
        }



        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name</param> 
        /// <param name="player"></param>
        /// <param name="combos">Combos (ex. KeyCodeExtension.Backspace.DOUBLE,KeyCodeExtesnion.Joystick1AxisYPositive.SINGLE)</param>
        public static void MapStateToInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, params InputAction[] actions)
        {
            MapStateToInput(stateName, new InputCombination(actions),player);
        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name.</param>
        /// <param name="combination">Combination.</param>    
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>

        public static void MapStateToInput(string stateName, InputCombination combination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            if (at > 2) throw new Exception("Only indexes 0(Primary) and 1(Secondary) input are allowed");

            if (!isReady())
                return;

            int stateNameHash = Animator.StringToHash(stateName);
            InputState state;

            if (!__settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash))
            {
                //create InputState and add to Dictionary of state inputs
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash] = new InputState(stateName, stateNameHash);
            }
            else
            {
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash];
            }

            state.Add(combination, at);

        }


        /// <summary>
        /// Maps state to input.
        /// </summary>
        /// <param name="stateName">State name hash.</param>
        /// <param name="combination">Combination.</param>
        /// <param name="player"></param>
        /// <param name="player"></param>
        /// <param name="at">At.Valid:-1(next) or 0(primary) and 1(secondary)</param>
        public static void MapStateToInput(int stateNameHash, InputCombination combination, InputPlayer.Player player = InputPlayer.Player.Player0, int at = -1)
        {

            if (at > 2) throw new Exception("Only indexes 0(Primary) and 1(Secondary) input are allowed");
            if (!isReady())
                return;

            InputState state;

            if (!__settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash))
            {
                //create InputState and add to Dictionary of state inputs
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash] = new InputState("GenState_" + stateNameHash, stateNameHash);
            }
            else
            {
                state = __settings.GetInputStatesOfPlayer(player)[stateNameHash];
            }

            state.Add(combination, at);

        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateNameHash"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static bool HasInputState(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {

            return isReady() && __settings.GetInputStatesOfPlayer(player).ContainsKey(stateNameHash);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static bool HasInputState(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
        {

            return isReady() && InputManager.HasInputState(Animator.StringToHash(stateName),player);
        }


		public static void addEvents(InputEvent[] events,InputPlayer.Player player=InputPlayer.Player.Player0){

			int len = events.Length;
				  
			for (int i=0; i<len; i++)
								__settings.Players [(int)player].AddEvent (events [i]);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stateNameHash"></param>
        /// <param name="player"></param>
        /// <returns></returns>
        public static InputEvent addEventListener(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
            if (isReady())

                return __settings.Players[(int)player].GetEvent(stateNameHash);

            return null;
        }

        /// <summary>
        /// 
        /// </summary>
        internal static void dispatchEvent()
        {
           
			if (!isReady ())
								return;
			int numPlayers = __settings.Players.Length;


			Dictionary<int, InputEvent> stateEvents;


			for (int i=0; i<numPlayers; i++) {
				stateEvents= __settings.Players[i].stateEvents;

								if (stateEvents != null)
										foreach (var stateInputEventsPair in stateEvents) {
										
														if (InputManager.GetInputHold (stateInputEventsPair.Key,i)) {
															stateInputEventsPair.Value.onHOLD.Invoke();
														}

															if (InputManager.GetInputDown (stateInputEventsPair.Key,i)) {
																stateInputEventsPair.Value.onDOWN.Invoke();
															}

															if (InputManager.GetInputUp (stateInputEventsPair.Key,i)) {
																stateInputEventsPair.Value.onUP.Invoke();
															}
	

										}
						}
        }



     








        ///!!!! UNITY DOESN"T INCLUDE SYSTEM.XML (OR SOME PARTS OF IT) SO RUNTIME SERIALIZATION DOESN"T WORK IN WEBPLAYER
        /// manual deserialzation is done with addtional methods for WEBPLAYER 
        /// TODO mulitplayer changes for webplayer ser/des should be done if there is interest of community


#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
		public static InputSettings loadSettingsFromBin(String path){
			
			
			using (Stream stream = new FileStream(path,FileMode.Open,FileAccess.Read)) {
				BinaryFormatter bf=new BinaryFormatter();
				__settings = (InputManager.InputSettings)bf.Deserialize (stream);
				stream.Close ();
			}
			
			return __settings;
		}




        /// <summary>
        /// Loads the Input settings from InputSettings.xml and deserialize into OO structure.
        /// Create your .xml settings with InputMapper Editor
        /// </summary>
        public static InputSettings loadSettings(String path = "InputSettings.xml")
        {

			if (!File.Exists (path)) {
				UnityEngine.Debug.LogError("File Not found "+path);
				//return null;
			}

			if (Path.GetExtension (path) != ".xml" && Path.GetExtension (path) != ".bin") {
								throw new Exception ("Not supported file type. Please use XML or BIN");
				//return null;
			}

			if (Path.GetExtension (path) == ".bin") {
				return	loadSettingsFromBin(path);

			}


            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;



            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");
            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            using (XmlReader reader = XmlReader.Create(path, xmlSettings))
            {

                __settings = (InputSettings)serializer.ReadObject(reader);

            }



            return __settings;
        }


        public static InputSettings loadSettings(StringReader stringReader)
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;




            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");
            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            using (XmlReader reader = XmlReader.Create(stringReader, xmlSettings))
            {

                __settings = (InputSettings)serializer.ReadObject(reader);

            }



            return __settings;
        }
#endif


		/// <summary>
		/// Loads the settings from XML text.
		/// </summary>
		/// <returns>The settings from XML text.</returns>
		/// <param name="path">Path.</param>
		/// <param name="readBOM">If set to <c>true</c> read BO.</param>
		public static InputSettings loadSettingsFromXMLText(string path, bool readBOM = true)
		{
			XmlReaderSettings xmlSettings = new XmlReaderSettings();
			xmlSettings.CloseInput = true;
			xmlSettings.IgnoreWhitespace = true;
		
			
		
			
			using (XmlReader reader = XmlReader.Create(path, xmlSettings)) {
				
				if (readBOM)
					reader.Read();//skip BOM


				
				readSettings(reader);
				

				

				
			}// UnityEngine.Debug.Log("end reader");

			return __settings;
		}


		/// <summary>
		/// Loads the settings from text.
		/// </summary>
		/// <returns>The settings from text.</returns>
		/// <param name="text">Text.</param>
		/// <param name="readBOM">If set to <c>true</c> read BO.</param>
        public static InputSettings loadSettingsFromText(string text, bool readBOM = true)
        {
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.CloseInput = true;
            xmlSettings.IgnoreWhitespace = true;
            StringReader stringReader = new StringReader(text);

            if (readBOM)
              stringReader.Read();//skip BOM

            using (XmlReader reader = XmlReader.Create(stringReader, xmlSettings)) {


								__settings = new InputSettings ();

								readSettings(reader);

								stringReader.Close ();

								

			}// UnityEngine.Debug.Log("end reader");

			return __settings;
}





#if UNITY_WEBPLAYER && !UNITY_EDITOR
		public static IEnumerator saveSettings(String url){

        //V1
			//WWWForm wwwForm=new WWWForm();
			//wwwForm.AddField("data",formatOutput);

			//WWW www=new WWW(url,wwwForm);

           
            string str=formatOutput();
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            WWW www=new WWW(url,bytes);
           
           

			yield return www;

            if(www.error!=null) UnityEngine.Debug.LogError(www.error);
		}

#endif


		internal static void readSettings(XmlReader reader){

			__settings = new InputSettings ();

			int key;
			
			InputAction action;
			List<InputAction> actions = null;
			InputCombination[] combinations = null;
			string name;
			InputState state;
			int i;
			List<InputPlayer> playerList;
			InputPlayer player;
			string profileKey;
			Dictionary<int,InputState> stateInputs;
			//XmlNameTable nameTable = reader.NameTable;
			//XmlNamespaceManager nsManager = new XmlNamespaceManager(nameTable);
			//nsManager.AddNamespace("d1p1", "http://schemas.datacontract.org/2004/07/ws.winx.input");
			
			reader.ReadToFollowing ("d1p1:doubleDesignator");
			__settings.doubleDesignator = reader.ReadElementContentAsString ();
			
			
			__settings.longDesignator = reader.ReadElementContentAsString ();
			
			
			__settings.spaceDesignator = reader.ReadElementContentAsString ();
			
			
			
			
			__settings.singleClickSensitivity = reader.ReadElementContentAsFloat ();
			
			
			__settings.doubleClickSensitivity = reader.ReadElementContentAsFloat ();
			
			
			__settings.longClickSensitivity = reader.ReadElementContentAsFloat ();
			
			
			__settings.combinationsClickSensitivity = reader.ReadElementContentAsFloat ();
			
			
			
			
			
			
			if (reader.ReadToFollowing ("d1p1:InputPlayer")) {
				
				playerList = new List<InputPlayer> ();
				
				do {
					
					player = new InputPlayer ();
					
					playerList.Add (player);
					
					
					if (reader.ReadToFollowing ("d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState")) {
						
						
						do {
							reader.ReadToDescendant ("d4p1:Key");
							
							profileKey = reader.ReadElementContentAsString ();
							
							
							
							if (reader.ReadToFollowing ("d4p1:KeyValueOfintInputState")) {
								
								stateInputs=new Dictionary<int, InputState>();
								
								do {
									
									
									
									
									reader.ReadToDescendant ("d4p1:Key");
									
									key = reader.ReadElementContentAsInt ();
									
									
									
									
									if (reader.ReadToFollowing ("d1p1:InputCombination")) {
										
										combinations = new InputCombination[2];
										i = 0;
										
										do {
											if (reader.GetAttribute ("i:nil") == null) {
												
												
												if (reader.ReadToDescendant ("d1p1:InputAction")) {
													actions = new List<InputAction> ();
													
													do {
														reader.ReadToDescendant ("d1p1:Code");
														
														action = new InputAction (reader.ReadElementContentAsString ());
														
														actions.Add (action);
														
													} while (reader.ReadToNextSibling("d1p1:InputAction"));
													
													
												}
												
												
												
												
												combinations [i++] = new InputCombination (actions);
												
												reader.Read ();//read </InputCombination>
												
											}
											
											
											
										} while (reader.ReadToNextSibling("d1p1:InputCombination"));
										
										
										
									}
									
									reader.ReadToFollowing ("d1p1:Name");
									name = reader.ReadElementContentAsString ();
									state = new InputState (name, key);
									state.combinations = combinations;
									
									
									//Shound be extended to multiplayer expansion
									stateInputs[key] = state;
									
									
									reader.Read ();//</d4p1:KeyValueOfintInputState>
									
								} while (reader.ReadToNextSibling("d4p1:KeyValueOfintInputState"));
								
								player.DeviceProfileStateInputs [profileKey] = stateInputs;
								
							}//
							
							
							
							
							reader.Read ();//</d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>
							
						} while(reader.ReadToNextSibling("d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState"));
						
						
						
					}
					
					if (reader.ReadToFollowing ("d1p1:_deviceID") && reader.GetAttribute ("i:nil") == null) {
						player.DeviceID = reader.ReadElementContentAsString ();
					}
					
					if (reader.ReadToFollowing ("d1p1:Name") && reader.GetAttribute ("i:nil") == null) {
						player.Name = reader.ReadElementContentAsString ();
					}else
						
						
						
						reader.Read ();//</d1p1:InputPlayer>
					
				} while(reader.ReadToNextSibling("d1p1:InputPlayer"));
				
				
				__settings.Players = playerList.ToArray ();
			}


		}

        public static string formatOutput()
        {


           


            string HEADFORMAT = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
   "<Inputs xmlns:d1p1=\"http://schemas.datacontract.org/2004/07/ws.winx.input\" xmlns:i=\"http://www.w3.org/2001/XMLSchema-instance\">" +
    " <d1p1:doubleDesignator>{0}</d1p1:doubleDesignator>" +
    " <d1p1:longDesignator>{1}</d1p1:longDesignator>" +
    " <d1p1:spaceDesignator>{2}</d1p1:spaceDesignator>" +
    " <d1p1:singleClickSensitivity>{3}</d1p1:singleClickSensitivity>" +
    " <d1p1:doubleClickSensitivity>{4}</d1p1:doubleClickSensitivity>" +
   "  <d1p1:longClickSensitivity>{5}</d1p1:longClickSensitivity>" +
   "  <d1p1:combinationsClickSensitivity>{6}</d1p1:combinationsClickSensitivity>" +
	"<d1p1:Players>" +

    " {7}" +
					"</d1p1:Players>" +
   "</Inputs>";

			string EMPTY_TAG_FORMAT = "<d1p1:{0} i:nil=\"true\" />";
			string TAG_FORMAT = "<d1p1:{0}>{1}<d1p1:{0}/>";
		    

			string PROFILEFORMAT =
								 "<d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>"
								+ "<d4p1:Key>{0}</d4p1:Key>"
								+ "<d4p1:Value>"
								+ "{1}</d4p1:Value>"
					+ "</d4p1:KeyValueOfstringArrayOfKeyValuePairOfintInputState>";
								
									
			string DEVICE_STATES_INPUTS_FORMAT=
				"<d1p1:_DeviceStateInputs xmlns:d4p1=\"http://schemas.microsoft.com/2003/10/Serialization/Arrays\">"+
				"{0}"+
					"</d1p1:_DeviceStateInputs>";

					string INPUTPLAYER =
					"<d1p1:InputPlayer>" +
					"{0}"+
					"</d1p1:InputPlayer>";

            string STATEFORMAT = " <d4p1:KeyValueOfintInputState>" +
									" <d4p1:Key>{0}</d4p1:Key>" +
							      " <d4p1:Value>" +
							       "  <d1p1:Hash>{0}</d1p1:Hash>" +
							        " <d1p1:InputCombinations>" +
							           " {1}" +

							        " </d1p1:InputCombinations>" +
							       "  <d1p1:Name>{2}</d1p1:Name>" +
							      " </d4p1:Value>" +
							     "</d4p1:KeyValueOfintInputState>";


            string COMBINATIONFORMAT =
                    "   <d1p1:InputCombination>" +
                   "     <d1p1:InputActions>" +
                  "{0}" +
                   "     </d1p1:InputActions>" +
                  "   </d1p1:InputCombination>";

            string ACTIONFORMAT =
                       "       <d1p1:InputAction>" +
                 "         <d1p1:Code>{0}</d1p1:Code>" +
                   "       </d1p1:InputAction>";
            string actionsString;

           
            Dictionary<int, InputState> stateInputs;// = InputManager.Settings.stateInputs;
            InputCombination[] combinations;
            InputCombination combination;

            int key;
            StringBuilder statesSB = new StringBuilder(10000);
            StringBuilder combinationSB = new StringBuilder(100);
			StringBuilder profilesSB = new StringBuilder(100000);
			StringBuilder playersSB = new StringBuilder(100000);

			int numPlayers = __settings.Players.Length;
			InputPlayer player;
			for (int playerInx=0; playerInx<numPlayers; playerInx++) {

						player = __settings.Players [playerInx];

						profilesSB.Length=0;

						foreach (KeyValuePair<string, Dictionary<int,InputState>> profileStateInput in player.DeviceProfileStateInputs) {

								stateInputs = profileStateInput.Value;

								statesSB.Length=0;

								foreach (KeyValuePair<int, InputState> stateInput in stateInputs) {
										key = stateInput.Key;
										combinations = stateInput.Value.combinations;

										combinationSB.Length = 0;


										if ((combination = combinations [0]) != null) {
												actionsString = "";

												foreach (InputAction action in combination.actionsList) {
														actionsString += String.Format (ACTIONFORMAT, action.ToString ());
												}

												combinationSB.AppendFormat (COMBINATIONFORMAT, actionsString);
										}

										if ((combination = combinations [1]) != null) {
												actionsString = "";
												foreach (InputAction action in combination.actionsList) {
														actionsString += String.Format (ACTIONFORMAT, action.ToString ());
												}

												combinationSB.AppendFormat (COMBINATIONFORMAT, actionsString);
										}


										statesSB.AppendFormat (STATEFORMAT, key, combinationSB.ToString (), stateInput.Value.name);

										
								}//StateInputs

					profilesSB.AppendFormat(PROFILEFORMAT,profileStateInput.Key,statesSB.ToString());	

						}//DeviceProfileStateInputs

							statesSB.Length=0;
							statesSB.AppendFormat(DEVICE_STATES_INPUTS_FORMAT,profilesSB.ToString());

							if(!String.IsNullOrEmpty(player.DeviceID)){
								statesSB.AppendFormat(TAG_FORMAT,"_deviceID",player.DeviceID);
							}else{
								statesSB.AppendFormat(EMPTY_TAG_FORMAT,"_deviceID");
							}

							if(!String.IsNullOrEmpty(player.Name)){
								statesSB.AppendFormat(TAG_FORMAT,"Name",player.Name);
							}else{
								statesSB.AppendFormat(EMPTY_TAG_FORMAT,"Name");
							}

								playersSB.AppendFormat(INPUTPLAYER,statesSB.ToString());

							

				}//players

        
            return String.Format(HEADFORMAT, __settings.doubleDesignator, __settings.longDesignator, __settings.spaceDesignator, __settings.singleClickSensitivity, __settings.doubleClickSensitivity, __settings.longClickSensitivity, __settings.combinationsClickSensitivity,
                                playersSB.ToString());
        }


#if UNITY_WEBPLAYER && UNITY_EDITOR
       public static void saveSettings(string path){
           XmlWriterSettings xmlSettings = new XmlWriterSettings();
           xmlSettings.Indent = true;
           xmlSettings.CloseOutput = true;//this would close stream after write 
          




           using (XmlWriter writer = XmlWriter.Create(path, xmlSettings))
           {
             
               writer.WriteRaw( formatOutput());
               



               //Write the XML to file and close the writer.
               writer.Flush();
               writer.Close();


           }


			Debug.Log(InputManager.Log());
       }
#endif

		internal static void saveSettingsBin(String path)
		{
			using (FileStream ms = new FileStream(path,FileMode.Create,FileAccess.Write))
						{
							var bin = new BinaryFormatter();
							bin.Serialize(ms, __settings);
							ms.Flush();
							ms.Close();
						} 
		}
			
			#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID)&& !UNITY_WEBPLAYER
        /// <summary>
        /// Saves the settings to InputSettings.xml.
        /// </summary>
        public static void saveSettings(String path)
        {
			if (Path.GetExtension(path)==".bin") {
					saveSettingsBin (path);
				return;

			}



            //DataContractSerializer serializer = new DataContractSerializer(typeof(Dictionary<int,InputCombination[]>),"Inputs","");

            DataContractSerializer serializer = new DataContractSerializer(typeof(InputSettings), "Inputs", "");


            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.Indent = true;
            xmlSettings.CloseOutput = true;//this would close stream after write 
            //	xmlSettings.IndentChars="\t";
            //	xmlSettings.NewLineOnAttributes = false;
            //	xmlSettings.OmitXmlDeclaration = true;





            using (XmlWriter writer = XmlWriter.Create(path, xmlSettings))
            {
                //serializer.WriteObject(writer, __settings.stateInputs);
                serializer.WriteObject(writer, __settings);

                //Write the XML to file and close the writer.
                writer.Flush();
                writer.Close();


            }



        }

#endif

        public static void processGUIEvent(Event current)
        {
            InputEx.processGUIEvent(current);
        }






        //public void resetMap(){
        //}


        /// <summary>
        /// Gets action from IDevice or if null
        /// gets the action that happens on any keyboard,mouse or game controller input.(useful for building user mapping interface)
        /// </summary>
        /// <returns>The action.</returns>
        /// <param name="">.</param>
        public static InputAction GetAction(IDevice device)
        {
            if (__settings != null)
                return InputEx.GetAction(device);
            else
                return null;
        }




        /// <summary>
        /// Gets the input of generic created values in range 0f to +/-1f
        /// in steps defined with "sensitivity" param
        /// while key, button,mouse,axis being HOLD
        /// </summary>
        /// <returns> 0f to +/-1f</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="sensitivity">Sensitivity of rising value 0f to 1f</param>
        /// <param name="dreadzone">Dreadzone.If value drop under dreadzone value would be nullify</param>
        /// <param name="gravity">Gravity. After no signal from input value would drop with step of gravity or immidiately</param>
        public static float GetInput(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return 0f;

            __inputCombinations = __settings.GetInputStatesOfPlayer(player)[stateNameHash].combinations;

            IDevice device = __settings.Players[(int)player].Device;

            return Mathf.Clamp(__inputCombinations[0].GetInputGenerated(device,sensitivity, dreadzone, gravity) + (__inputCombinations.Length == 2 && __inputCombinations[1] != null ? __inputCombinations[1].GetInputGenerated(device,sensitivity, dreadzone, gravity) : 0),-1f,1f);

        }

		/// <summary>
		/// Gets the input.
		/// </summary>
		/// <returns>The input.</returns>
		/// <param name="stateName">State name.</param>
		/// <param name="player">Player.</param>
		/// <param name="sensitivity">Sensitivity.</param>
		/// <param name="dreadzone">Dreadzone.</param>
		/// <param name="gravity">Gravity.</param>
		public static float GetInput(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
		{
			return GetInput (Animator.StringToHash (stateName), player, sensitivity, dreadzone, gravity);
		}
			
			
			
		/// <summary>
        /// Gets the input of device(hardware)
        /// if device's input mapped is digital would return -1f to 1f generic values emulating analog hardware 
        /// if device's input mapped is analog would return 0f to 1f(positive axis) or 0f to -1f(negative axis) 
		/// full axis -1f to 1f
        /// </summary>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        /// <param name="sensitivity">Sensitivity of rising value 0f to 1f</param>
        /// <param name="dreadzone">Dreadzone.If value drop under dreadzone value would be nullify</param>
        /// <param name="gravity">Gravity. After no signal from input value would drop with step of gravity or immidiately</param>
        /// 
        public static float GetInputRaw(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return 0f;

            __inputCombinations = __settings.GetInputStatesOfPlayer(player)[stateNameHash].combinations;

            IDevice device = __settings.Players[(int)player].Device;

            return Mathf.Clamp(__inputCombinations[0].GetAnalogValue(device,sensitivity, dreadzone, gravity) + (__inputCombinations.Length == 2 && __inputCombinations[1] != null ? __inputCombinations[1].GetAnalogValue(device,sensitivity, dreadzone, gravity) : 0f), -1f, 1f);

        }

		/// <summary>
		/// [Use for testing as string to hash is slow operat
		/// Gets the input of device(hardware)
		/// if device's input mapped is digital would return -1f to 1f generic values emulating analog hardware 
		/// if device's input mapped is analog would return 0f to 1f(positive axis) or 0f to -1f(negative axis) 
		/// full axis -1f to 1f
		/// </summary>
		/// <returns>The input raw.</returns>
		/// <param name="stateNameHash">State name hash.</param>
		/// <param name="player">Player.</param>
		/// <param name="sensitivity">Sensitivity.</param>
		/// <param name="dreadzone">Dreadzone.</param>
		/// <param name="gravity">Gravity.</param>
		public static float GetInputRaw(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, float sensitivity = 0.1f, float dreadzone = 0.1f, float gravity = 0.3f)
		{
			return GetInputRaw (Animator.StringToHash (stateName), player, sensitivity, dreadzone, gravity);
		}
			
			
		/// <summary>
		/// HOLD.
		/// </summary>
		/// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
		/// <param name="stateNameHash">State name hash.</param>
		/// <param name="playerIndex">Player index.</param>
		internal static bool GetInputHold(int stateNameHash, int playerIndex){

			//Use is mapping states so no quering keys during gameplay
			if (!InputManager.isReady()) return false;
			
			__inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;
			
			IDevice device = __settings.Players[playerIndex].Device;
			
			return __inputCombinations[0].GetInputHold(device) || (__inputCombinations.Length == 2 && __inputCombinations[1] != null && __inputCombinations[1].GetInputHold(device));

		}
		

		/// <summary>
		/// HOLD.
		/// </summary>
		/// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
		/// <param name="stateNameHash">State name hash.</param>
		/// <param name="player">Player.</param>
        public static bool GetInputHold(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
			return GetInputHold (stateNameHash, (int)player);
        }



		/// <summary>
		/// HOLD.[Use for testing as string to hash is slow operat
		/// </summary>
		/// <returns><c>true</c>, while input binded to state returns signal, <c>false</c> otherwise.</returns>
		/// <returns><c>true</c>, if input hold was gotten, <c>false</c> otherwise.</returns>
		/// <param name="stateName">State name.</param>
		/// <param name="player">Player.</param>
		public static bool GetInputHold(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
		{
			return GetInputHold (Animator.StringToHash(stateName), player);
		}




		internal static bool GetInputUp(int stateNameHash, int playerIndex=0)
		{
			//Use is mapping states so no quering keys during gameplay
			if (!InputManager.isReady()) return false;
			
			__inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;
			
			
			IDevice device = __settings.Players[playerIndex].Device;
			return __inputCombinations[0].GetInputUp(device) || (__inputCombinations.Length == 2 && __inputCombinations[1] != null && __inputCombinations[1].GetInputUp(device));

		}
			
		/// <summary>
        /// UP.
        /// </summary>
        /// <returns><c>true</c>, if input binded to state stopped to return values(then is reseted), <c>false</c> otherwise.</returns>
        /// <param name="stateNameHash">State name hash.</param>
        /// <param name="player"></param>
        public static bool GetInputUp(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0)
        {
			return GetInputUp (stateNameHash, (int)player);
        }


		/// <summary>
		/// UP.[Use for testing as string to hash is slow operation in loop]
		/// </summary>
		/// <returns><c>true</c>, if input binded to state stopped to return values(then is reseted), <c>false</c> otherwise.</returns>
		/// <param name="stateName">State name.</param>
		/// <param name="player">Player.</param>
		public static bool GetInputUp(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0)
		{
			return GetInputUp (Animator.StringToHash (stateName), player);
		}
			

		/// <summary>
		/// Gets the input down.
		/// </summary>
		/// <returns><c>true</c>, if input down was gotten, <c>false</c> otherwise.</returns>
		/// <param name="stateNameHash">State name hash.</param>
		/// <param name="playerIndex">Player index.</param>
		/// <param name="atOnce">If set to <c>true</c> at once.</param>
       internal static bool GetInputDown(int stateNameHash, int playerIndex=0, bool atOnce = false)
        {
            //Use is mapping states so no quering keys during gameplay
            if (!InputManager.isReady()) return false;

            //__settings.Players[InputManager.currentPlayerInx].GetStateInputBasedOnControllerMappedToPlayer

            __inputCombinations = __settings.GetInputStatesOfPlayer(playerIndex)[stateNameHash].combinations;

            IDevice device = __settings.Players[playerIndex].Device;

            return __inputCombinations[0].GetInputDown(device,atOnce) || (__inputCombinations.Length == 2 && __inputCombinations[1] != null && __inputCombinations[1].GetInputDown(device,atOnce));
        }



		/// <summary>
		/// DOWN.
		/// </summary>
		/// <returns><c>true</c>, if input binded to state started to return values (than is reseted), <c>false</c> otherwise.</returns>
		/// <param name="stateNameHash">State name hash.</param>
		/// <param name="player"></param>
		/// <param name="atOnce">(combos effective only) default=<c>false</c> expect combo parts successive action (ex. W+C => W pressed,released then C pressed)
		/// atOnce=true useful for building modifires like behaviour (LeftCtrl(-)+C)</param>	
		public static bool GetInputDown(int stateNameHash, InputPlayer.Player player = InputPlayer.Player.Player0, bool atOnce = false)
		{
			return GetInputDown (stateNameHash, (int)player, atOnce);
		}


		/// <summary>
		/// DOWN.[Use for testing as string to hash is slow operation in loop]
		/// </summary>
		/// <returns><c>true</c>, if input binded to state started to return values (than is reseted), <c>false</c> otherwise.</returns>
		/// <param name="stateName">State name.</param>
		/// <param name="player">Player.</param>
		/// <param name="atOnce">If set to <c>true</c> at once.</param>
		public static bool GetInputDown(string stateName, InputPlayer.Player player = InputPlayer.Player.Player0, bool atOnce = false)
		{ 
			return GetInputDown (Animator.StringToHash (stateName), player, atOnce);
		}
			
			/// <summary>
        /// Log states - inputs values to console
        /// </summary>
        public static string Log()
        {
            StringBuilder content = new StringBuilder();
            int i;
            int j;
            //primary,secondary...
            InputCombination[] combinations;

            for (j = 0; j < __settings.Players.Length; j++)
                foreach (var keyValuPair in __settings.GetInputStatesOfPlayer((InputPlayer.Player)j))
                {
                    content.AppendLine("Name:" + keyValuPair.Value.name + " Key:" + keyValuPair.Key);
                    combinations = keyValuPair.Value.combinations;

                    for (i = 0; i < combinations.Length; i++)
                    {
                        if (combinations[i] != null)
                            content.AppendLine(i + ": " + combinations[i].ToString());
                    }

                    content.AppendLine();


                }


            return content.ToString();

        }









        public static void Dispose()
        {

            Debug.Log("InputManager Dispose");

            if (__hidInterface != null)
            {
                Debug.Log("Try to remove HidInterface events");
              
                __hidInterface.DeviceDisconnectEvent -= new EventHandler<DeviceEventArgs<string>>(onRemoveDevice);


                __hidInterface.DeviceConnectEvent -= new EventHandler<DeviceEventArgs<IDevice>>(onAddDevice);


                __hidInterface.Dispose();
                __hidInterface = null;
            }

            int error = Marshal.GetLastWin32Error();
            if (error > 0)

                UnityEngine.Debug.Log(" Win32Error Erorr" + error);


            if (InputEx.Devices != null)
            {
                Debug.Log("Try to remove devices");
                lock (syncRoot)
                {
                    InputEx.Devices.Clear();
                }
            }

            Debug.Log("Try to remove states per player");
            InputPlayer[] players = InputManager.Settings.Players;
            if (players != null)
                for (int i = 0; i < players.Length; i++)
                {

                    foreach (var DeviceStateInputPair in players[i].DeviceProfileStateInputs)
                    {
                        DeviceStateInputPair.Value.Clear();

                    }


                    players[i].DeviceProfileStateInputs.Clear();

                }

            //		if (InputManager.Settings.stateInputs != null)
            //								InputManager.Settings.stateInputs.Clear ();

            Debug.Log("Dispose Finished");


            if (error > 0)

                UnityEngine.Debug.Log(" Win32Error Erorr" + error);
        }



        #region Settings

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
        [DataContract]
#endif
		[System.Serializable]
        public class InputSettings
        {

		


#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 4)]
#endif
            public float singleClickSensitivity
            {
                get { return InputAction.SINGLE_CLICK_SENSITIVITY; }
                set { InputAction.SINGLE_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 5)]
#endif
            public float doubleClickSensitivity
            {
                get { return InputAction.DOUBLE_CLICK_SENSITIVITY; }
                set { InputAction.DOUBLE_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 6)]
#endif
            public float longClickSensitivity
            {
                get { return InputAction.LONG_CLICK_SENSITIVITY; }
                set { InputAction.LONG_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 7)]
#endif
            public float combinationsClickSensitivity
            {
                get { return InputAction.COMBINATION_CLICK_SENSITIVITY; }
                set { InputAction.COMBINATION_CLICK_SENSITIVITY = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 1)]
#endif
            public string doubleDesignator
            {
                get { return InputAction.DOUBLE_DESIGNATOR; }
                set { InputAction.DOUBLE_DESIGNATOR = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 2)]
#endif
            public string longDesignator
            {
                get { return InputAction.LONG_DESIGNATOR; }
                set { InputAction.LONG_DESIGNATOR = value; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Order = 3)]
#endif
            public string spaceDesignator
            {
                get { return InputAction.SPACE_DESIGNATOR.ToString(); }
                set { InputAction.SPACE_DESIGNATOR = value[0]; }

            }

#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            [DataMember(Name = "Players", Order = 9)]
#endif
            protected InputPlayer[] _players;

            public InputPlayer[] Players
            {
                get { return _players; }
                set { _players = value; }
            }



			internal Dictionary<int, InputState> GetInputStatesOfPlayer(InputPlayer.Player player){
				return GetInputStatesOfPlayer ((int)player);

			}


            internal Dictionary<int, InputState> GetInputStatesOfPlayer(int index)
            {


                InputPlayer player = _players[index];

                //if there is device attached to player
                if (player.Device != null)
                {
                    string profileName = player.Device.profile != null ? player.Device.profile.Name : "default";

                    if (player.DeviceProfileStateInputs.ContainsKey(profileName))
                    {
                        return player.DeviceProfileStateInputs[profileName];

                    }

                }

                return player.DeviceProfileStateInputs["default"];


            }





            //			#if (UNITY_STANDALONE || UNITY_EDITOR || UNITY_ANDROID) && !UNITY_WEBPLAYER
            //			[DataMember(Name="StateInputs",Order=9)]
            //			#endif
            //			protected Dictionary<int,InputState> _stateInputs;

            //public Dictionary<int,InputState> stateInputs{
            //    get {return GetInputStatesOfPlayer(InputManager.currentPlayerIndex);}
            //}


            public InputSettings()
            {
                //_stateInputs=new Dictionary<int,InputState>();

            }
        }
        #endregion







    }
}


